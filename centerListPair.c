/*
  Input: k1 list_hash1 k2 list_hash2 budget

  The list_hash files are generated by assignAll.c. For each k-mer x,
  the loaded hash value is a list of pairs (c, d) where c is 
  (the index of) a center and edit(x, c)=d. The list is sorted by d,
  break ties with c.
   
  Let k = k1 + k2. For d = 1 .. k/2:
  i) generata N pairs of k-mers with edit distance d
  ii) for a pair (s, t), s is consists of a k1-prefix s1 and a k2-suffix s2.
  Similarly for t=t1+t2.
  iii) s is hashed to buckets (c1, c2) for all c1 in list_hash1[s1] with 
  dist d1 and c2 in list_hash2[s2] with dist d2 such that d1+d2<=budget.
  Similar for t.
  iii) s and t has a collision if s and t are hashed to a same bucket.

  By: Ke@PSU
  Last edited: 01/22/2022
*/

#include "util.h"
#include "AVLTree.h"
#include <time.h>
#include <string.h>

#define N 100000
#define luMB 0x8000000000000000lu

typedef struct{
    size_t centers[2];
}CenterPair;

int cmpCenterPair(const void* a, const void* b){
    size_t* ca = ((CenterPair*)a)->centers;
    size_t* cb = ((CenterPair*)b)->centers;
    if(ca[0] == cb[0]){
	if(ca[1] == cb[1]) return 0;
	else if(ca[1] < cb[1]) return -1;
	else return 1;
    }else if(ca[0] < cb[0]) return -1;
    else return 1;
}

typedef struct{
    size_t c_idx;
    int dist;
}Center;

typedef struct{
    int len;
    Center* centers;
}HashList;

void readHashFromFile(char* hash_file, int k, HashList* h, size_t n){
    FILE* fin = fopen(hash_file, "r");

    char* line = NULL;
    size_t len;

    size_t i, j;
    int size;
    
    for(i=0; i<n; i+=1){
	getdelim(&line, &len, ' ', fin); //kmer
	getdelim(&line, &len, ' ', fin); //ct
	size = atoi(line);
	h[i].len = size;
	h[i].centers = malloc_harder(sizeof *(h[i].centers) * size);

	for(j=0; j<size-1; j+=1){
	    getdelim(&line, &len, ' ', fin); //center_idx
	    h[i].centers[j].c_idx = atol(line);
	    getdelim(&line, &len, ' ', fin); //dist
	    h[i].centers[j].dist = atoi(line);
	}
	getdelim(&line, &len, ' ', fin); //center_idx
	h[i].centers[j].c_idx = atol(line);
	getdelim(&line, &len, '\n', fin); //dist
	h[i].centers[j].dist = atoi(line);
    }
    
    fclose(fin);
    free(line);
}

int reportAndCleanUp(int found, AVLNode* tree, CenterPair* cp){
    AVLFreeTree(tree, free);
    free(cp);
    return found;
}

int shareCenterPair(kmer s, kmer t, int k1, int k2,
		    HashList* h1, HashList* h2, int budget){

    kmer mask = (1<<(k2<<1))-1;
    kmer s1 = s>>(k2<<1);
    kmer s2 = s & mask;
    
    
    int i, j;
    int l1 = h1[s1].len;
    Center* c1 = h1[s1].centers;
    int l2 = h2[s2].len;
    Center* c2 = h2[s2].centers;

    AVLNode* tree = NULL;
    AVLNode* node;
    CenterPair* cp;
    int remain_budget;

    //if s1 and t1 exact match, allow full budget for s2 and t2
    for(i=0; i<l2; i+=1){
	if(c2[i].dist > budget) break;
	cp = malloc(sizeof *cp);
	cp->centers[0] = s1|luMB;
	cp->centers[1] = c2[i].c_idx;
	tree = AVLAdd(tree, cp, cmpCenterPair);
    }

    //if s2 and t2 exact match, allow full budget for s1 and t1
    for(i=0; i<l1; i+=1){
	if(c1[i].dist > budget) break;
	cp = malloc(sizeof *cp);
	cp->centers[0] = c1[i].c_idx;
	cp->centers[1] = s2|luMB;
	tree = AVLAdd(tree, cp, cmpCenterPair);
    }
    
    
    for(i=0; i<l1; i+=1){
	remain_budget = budget - c1[i].dist;
	for(j=0; j<l2; j+=1){
	    //centers are sorted in ascending order by dist
	    if(c2[j].dist > remain_budget) break;
	    
	    cp = malloc(sizeof *cp);
	    cp->centers[0] = c1[i].c_idx;
	    cp->centers[1] = c2[j].c_idx;
	    node = AVLSearch(tree, cp, cmpCenterPair);
	    if(node){
		free(cp);
	    }else{
		tree = AVLAdd(tree, cp, cmpCenterPair);
	    }
	}
    }


    kmer t1 = t>>(k2<<1);
    kmer t2 = t & mask;    
    l1 = h1[t1].len;
    c1 = h1[t1].centers;
    l2 = h2[t2].len;
    c2 = h2[t2].centers;
    cp = malloc(sizeof *cp);

    //if s1 and t1 exact match, allow full budget for s2 and t2
    for(i=0; i<l2; i+=1){
	if(c2[i].dist > budget) break;
	cp->centers[0] = t1|luMB;
	cp->centers[1] = c2[i].c_idx;
	node = AVLSearch(tree, cp, cmpCenterPair);
	if(node) return reportAndCleanUp(1, tree, cp);
    }

    //if s2 and t2 exact match, allow full budget for s1 and t1
    for(i=0; i<l1; i+=1){
	if(c1[i].dist > budget) break;
	cp->centers[0] = c1[i].c_idx;
	cp->centers[1] = t2|luMB;
	node = AVLSearch(tree, cp, cmpCenterPair);
	if(node) return reportAndCleanUp(1, tree, cp);
    }

    
    for(i=0; i<l1; i+=1){
	remain_budget = budget - c1[i].dist;
	for(j=0; j<l2; j+=1){
	    if(c2[j].dist > remain_budget) break;

	    cp->centers[0] = c1[i].c_idx;
	    cp->centers[1] = c2[j].c_idx;
	    node = AVLSearch(tree, cp, cmpCenterPair);
	    if(node) return reportAndCleanUp(1, tree, cp);
	}
    }

    return reportAndCleanUp(0, tree, cp);
}


int main(int argc, char* argv[]){
    if(argc != 6){
	printf("usage: centerListPair.out k1 list_hash1"
	       "k2 list_hash2 budget\n");
	return 1;
    }

    int k1 = atoi(argv[1]);
    char* hash_file1 = argv[2];
    int k2 = atoi(argv[3]);
    char* hash_file2 = argv[4];
    int k = k1+k2;
    int budget = atoi(argv[5]);

    size_t NUM_K1MERS = 1<<(k1<<1);
    HashList* h1 = malloc_harder(sizeof *h1 *NUM_K1MERS);
    size_t NUM_K2MERS = 1<<(k2<<1);
    HashList* h2 = malloc_harder(sizeof *h2 *NUM_K2MERS);

    readHashFromFile(hash_file1, k1, h1, NUM_K1MERS);
    readHashFromFile(hash_file2, k2, h2, NUM_K2MERS);

    srand(time(0));
    
    size_t i, j;
    kmer s, t;
    int share_center;

    printf("dist #sha sha%%\n");
    for(i=1; i<=k>>1; i+=1){
	share_center = 0;
	for(j=0; j<N; j+=1){
	    s = randomKMer(k);
	    t = randomEdit(s, k, i);
	    
	    if(shareCenterPair(s, t, k1, k2, h1, h2, budget)){
		share_center += 1;
	    }
	    /*
	    else{//for debugging
		s += 1;
	    }
	    */
	}
	printf("%zu %d %.2f%%\n", i,
	       share_center, share_center*100.0/N);
    }
    

    for(i=0; i<NUM_K1MERS; i+=1){
	free(h1[i].centers);
    }
    free(h1);

    for(i=0; i<NUM_K2MERS; i+=1){
	free(h2[i].centers);
    }
    free(h2);
    
    return 0;
}
