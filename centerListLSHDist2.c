/*
  Input: k listHashingFile L B

  The list_hash files are generated by assignAll.c. For each k-mer x,
  the loaded hash value is a list of pairs (c, d) where c is 
  (the index of) a center and edit(x, c)=d. The list is sorted by d,
  break ties with c.

  Let d=2
  Generata N pairs of k-mers with edit distance d. For a pair (s, t), 
  distinguish two cases
  i) s differs from t by 2 substituitions (exactly 2 mismatches)
  ii) s differs from t by 1 indels (more than 2 mismatches).

  For each case, s and t are said to have a collision if they share a
  center. Show the chances of each case and the collision probability for
  each case.

  By: Ke@PSU
  Last edited: 02/13/2022
*/

#include "util.h"
#include "AVLTree.h"
#include <time.h>
#include <string.h>

#define N 100000


typedef struct{
    int len;
    int total;
    size_t* centers;
}HashList;


void readHashFromFile(char* hash_file, int k, HashList* h, size_t n){
    FILE* fin = fopen(hash_file, "r");

    char* line = NULL;
    size_t len;

    size_t i, j;
    int size;
    
    
    for(i=0; i<n; i+=1){
	getdelim(&line, &len, ' ', fin); //kmer
	getdelim(&line, &len, ' ', fin); //ct
	size = atoi(line);
	h[i].len = size;
	h[i].centers = malloc_harder(sizeof *(h[i].centers) * size);

	for(j=0; j<size-1; j+=1){
	    getdelim(&line, &len, ' ', fin); //center_idx
	    h[i].centers[j] = atol(line);
	    getdelim(&line, &len, ' ', fin); //dist
	}
	getdelim(&line, &len, ' ', fin); //center_idx
	h[i].centers[j] = atol(line);
	getdelim(&line, &len, '\n', fin); //dist
    }
    
    fclose(fin);
    free(line);
}

int shareCenter(kmer s, kmer t, HashList* h){
    int i, j;
    int ls = h[s].len;
    size_t* cs = h[s].centers;
    int lt = h[t].len;
    size_t* ct = h[t].centers;

    for(i=0; i<ls; i+=1){
	for(j=0; j<lt; j+=1){
	    if(cs[i] == ct[j]){
		return 1;
	    }
	}
    }

    return 0;
}

//see beginning comment for details
int getEditType(kmer s, kmer t, int k){
    int i, ct=0;
    kmer mask=3lu;
    for(i=0; i<k; i+=1){
	if((s&mask) != (t&mask)){
	    ct += 1;
	}
	mask <<= 2;
    }
    if(ct == 2) return 0;
    else return 1;
}

int cmpCenters(const void* a, const void* b){
    long x = (long) a;
    long y = (long) b;
    long r = x-y;
    if(r<0) return -1;
    else if(r>0) return 1;
    else return 0;
}

//0-no center, 1-one center, 2-two centers
int getCenterType(kmer s, kmer t, AVLNode* ctree){
    int ct = 0;
    AVLNode* node = AVLSearch(ctree, (void*)s, cmpCenters);
    if(node) ct += 1;
    node = AVLSearch(ctree, (void*)t, cmpCenters);
    if(node) ct += 1;
    return ct;
}

int main(int argc, char* argv[]){
    if(argc != 4){
	printf("usage: centerListLSHDist2.out k listHashingFile centersFile\n");
	return 1;
    }

    int k = atoi(argv[1]);
    char* hash_file = argv[2];
    char* centers_file = argv[3];

    size_t NUM_KMERS = 1<<(k<<1);
    HashList* h = malloc_harder(sizeof *h *NUM_KMERS);
    readHashFromFile(hash_file, k, h, NUM_KMERS);

    srand(time(0));
    
    size_t i, j;
    kmer s, t;
    int share_center[2][3] = {{0, 0, 0}, {0, 0, 0}};
    int ct[2][3] = {{0, 0, 0}, {0, 0, 0}};
    int edit_type, center_type;

    size_t NUM_CENTERS;
    kmer* centers = readCentersFromFile(centers_file, k, &NUM_CENTERS);
    AVLNode* ctree = NULL;
    for(i=0; i<NUM_CENTERS; i+=1){
	ctree = AVLAdd(ctree, (void*)(centers[i]), cmpCenters);
    }
    free(centers);
    
    i=2;
    printf("edit_type center_type # #sha\n");
    for(j=0; j<N; j+=1){
	s = randomKMer(k);
	t = randomEdit(s, k, i);

	edit_type = getEditType(s, t, k);
	center_type = getCenterType(s, t, ctree);
	ct[edit_type][center_type] += 1;
	
	if(shareCenter(s, t, h)){
	    share_center[edit_type][center_type] += 1;
	}
    }

    for(i=0; i<2; i+=1){
	for(j=0; j<3; j+=1){
	    printf("%zu %zu %d %d %.2f%%\n",
		   i, j, ct[i][j], share_center[i][j],
		   share_center[i][j]*100.0/ct[i][j]);
	}
    }
    

    for(i=0; i<NUM_KMERS; i+=1){
	free(h[i].centers);
    }
    free(h);
    AVLFreeTree(ctree, NULL);
    
    return 0;
}
